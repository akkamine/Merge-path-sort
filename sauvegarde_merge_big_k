#include <stdlib.h>
#include <math.h>
#include <stdio.h>


#define N_THREADS 512
#define N_BLOCKS 1024

#define X 0
#define Y 1

/*********************************************/
/************* PATH BIG K ********************/
/*********************************************/

__global__ void pathBig_k(int *a, int *b, int *Aindex, int *Bindex, int sizeA, int sizeB){
    // cette fonction permet de construire Aindex, Bindex
    // Aindex et Bindex sont stockés en mémoire globale
    // ils permettent de stocker les points de ruptures entre threads
    
    // cette fonction est exécutée par un seul thread par block
    
    // cette fonction n'est pas exécutée par le dernier block
    if(blockIdx.x == N_BLOCKS-1)
        return;
    
    // i prend la valeur de cette diagonale
    const int i = (sizeA+sizeB)/N_BLOCKS * (blockIdx.x + 1);
    
	int K[2];
	int P[2];
	int Q[2];
    
    if(i>sizeA){
        K[X] = i - sizeA;
        K[Y] = sizeA;
        P[X] = sizeA;
        P[Y] = i - sizeA;
    }
    else{
        K[X] = 0; K[Y] = i;
        P[X] = i; P[Y] = 0;
    }

    while(1){

        int offset = (K[Y]-P[Y])/2;
        Q[X] = K[X] + offset;
        Q[Y] = K[Y] - offset;

        if(Q[Y] >= 0 && Q[X] <= sizeB && (Q[Y] == sizeA || Q[X] == 0 || a[ Q[Y] ] > b[ Q[X]-1 ]) ){
            if(Q[X] == sizeB || Q[Y] == 0 || a[ Q[Y]-1 ] <= b[ Q[X] ]){
                Aindex[blockIdx.x] = Q[Y];
                Bindex[blockIdx.x] = Q[X];
                break;
            }
            else{
                K[X] = Q[X] + 1;
                K[Y] = Q[Y] - 1;
            }
        }
        else{
            P[X] = Q[X] - 1;
            P[Y] = Q[Y] + 1;
        }
    }
}


/**********************************************/
/************* MERGE BIG K ********************/
/**********************************************/

__global__ void mergeBig_k(int *a, int *b, int *m, int *Aindex, int *Bindex, int sizeA, int sizeB){
	int K[2];
	int P[2];
	int Q[2];

	const int i = threadIdx.x + blockIdx.x * blockDim.x;
    const int local_i = threadIdx.x;
    
	if(local_i>=(sizeSA + sizeSB))
        return;

    // Taille des sous-tableaux de A et B stockés en mémoire shared du block
    int sizeSA = Aindex[blockIdx.x + 1] - Aindex[blockIdx.x];
    int sizeSB = Bindex[blockIdx.x + 1] - Bindex[blockIdx.x];
    
	extern __shared__ int sharedMem[]; //de taille sizeSA + sizeSB
	
	int *sA = sharedMem;
    int *sB = sizeSA*sizeof(int) + sharedMem;
    
    if(blockIdx.x == ((sizeA+sizeB)/NTPB)-1 && local_i < sizeSA)
        sA[local_i % sizeSA] = a[i%sizeA];
    else
        if(Aindex[blockIdx.x] <= i <= Aindex[blockIdx.x + 1])
            sA[local_i % sizeSA] = a[i%sizeA];
    
    if(blockIdx.x == ((sizeA+sizeB)/NTPB)-1 && local_i < sizeSB)
        sB[local_i % sizeSB] = b[i%sizeB];
    else
        if(Bindex[blockIdx.x] <= i <= Bindex[blockIdx.x + 1])
            sB[local_i % sizeSB] = b[i % sizeB];
    
    __syncthreads();
    
    if(local_i>sizeSA){
        K[0] = local_i - sizeSA;
        K[1] = sizeSA;
        P[0] = sizeSA;
        P[1] = local_i - sizeSA;
    }
    else{
        K[0] = 0; K[1] = local_i;
        P[0] = local_i; P[1] = 0;
    }

    while(1){

        int offset = (K[1]-P[1])/2;
        Q[0] = K[0] + offset;
        Q[1] = K[1] - offset;

        if(Q[1] >= 0 && Q[0] <= sizeSB && (Q[1] == sizeSA || Q[0] == 0 || sA[ Q[1] ] > sB[ Q[0]-1 ]) ){
            if(Q[0] == sizeSB || Q[1] == 0 || sA[ Q[1]-1 ] <= sB[ Q[0] ]){
					if(Q[1] < sizeSA && (Q[0] == sizeSB || sA[ Q[1] ] <= sB[ Q[0] ])){
                        m[i] = sA[Q[1]] ;
		  			}
		  			else{
						m[i] = sB[Q[0]];
		  			}
		  			break;
            }
            else{
                K[0] = Q[0] + 1;
                K[1] = Q[1] - 1;
            }
        }
        else{
            P[0] = Q[0] - 1;
            P[1] = Q[1] + 1;
        }
    }
}

int main(void){
    int sizeA = N;
    int sizeB = N;
    
	int *A;
	int *B;
	int *M;
	int nb_blocks = (N+NTPB-1)/NTPB; // A vérifier

	float time= 0.;
	cudaEvent_t start, stop;
	cudaEventCreate(&start);
	cudaEventCreate(&stop);

	A = (int*) malloc(sizeof(int)*sizeA);
	B = (int*) malloc(sizeof(int)*sizeB);
	M = (int*) calloc(sizeof(int),sizeA+sizeB);

	for (int i = 0; i < sizeA; i++)
		A[i] = i*2+1;
    
    for (int i = 0; i < sizeB; i++)
		B[i] = i*2;

	int *A_gpu;
	int *B_gpu;
	int *M_gpu;
    
    int *Aindex, *Bindex;

	cudaMalloc(&A_gpu, sizeA * sizeof(int));
	cudaMalloc(&B_gpu, sizeB * sizeof(int));
	cudaMalloc(&M_gpu, (sizeA+sizeB) * sizeof(int));

    cudaMalloc(&Aindex, nb_blocks * sizeof(int));
	cudaMalloc(&Bindex, nb_blocks * sizeof(int));

	cudaMemcpy(A_gpu, A, sizeA * sizeof(int), cudaMemcpyHostToDevice);
	cudaMemcpy(B_gpu, B, sizeB * sizeof(int), cudaMemcpyHostToDevice);

	cudaEventRecord(start);
    
    // recherche du découpage 
    pathBig_k<<<N_BLOCKS, 1>>>(A_gpu, B_gpu, Aindex, Bindex, sizeA, sizeB);
    
    mergeBig_k<<<N_BLOCK, N_THREAD>>>(A_gpu, B_gpu, M_gpu, Aindex, Bindex, sizeA, sizeB);

	cudaEventRecord(stop);
	cudaEventSynchronize(stop);
	cudaEventElapsedTime(&time, start, stop);
	printf("mergeSmall_k: temps écoulé = %f secs\n", time/1000);


	cudaMemcpy(M, M_gpu, 2*N*sizeof(int), cudaMemcpyDeviceToHost);
	for (int i = 0; i < 2*N; i++)
        printf("M[%d] = %d\n", i, M[i]);


	free(A);
	free(B);
	free(M);
	cudaFree(A_gpu);
	cudaFree(B_gpu);
	cudaFree(M_gpu);
	cudaEventDestroy(start);
	cudaEventDestroy(stop);
}
